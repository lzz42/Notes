# 高效程序的奥秘

## 基础

- 计算机运算与数学运算的区别
  - 操作数不同
  - 运算符扩充
  - Main Deference：使用模2指数简化加法、减法、乘法
  - 大数操作、逻辑运算
  - 如无特殊说明：字长为32b,有符号整型和无符号整型均使用二进制的补码形式
- 将一个计算机字长视为一个单一字节的向量
- 字节从右开始计数，最右侧计数为0
- 十六进制表示：0x
- 二进制表示：0b
- 记法
  - 运算符优先级

| 优先度 | C                 | 说明              |
| ------ | ----------------- | ----------------- |
| 16     | a[k]              | 选择分量          |
| 16     | f(x)              | 函数求值          |
| 15     | x++,x--           | 后置递增 后置递减 |
| 14     | ++x,--x           | 前置递增 前置递减 |
| 14     | (类型名)x         | 类型转换          |
| 14     | ~x                | 按位取反          |
| 14     | !x                | 逻辑取反          |
| 14     | -x                | 算术取负          |
| 13L    | x*y x/y x%y       | 乘法 除法 求余    |
| 12L    | x+y x-y           | 加法 减法         |
| 11L    | x<<y  x>>y        | 带0填充 左/右移位 |
| 10L    | x<y x<=y x>y x>=y | 有/无符号比较     |
| 9L     | x==y x!=y         | 相等 不等         |
| 8L     | x&y               | 按位与            |
| 7L     | x^y               | 按位异或          |
| 6L     | x \| y            | 按位或            |
| 5L     | x&&y              | 条件与            |
| 4L     | x\|\|y            | 条件或            |
| 2R     | x=y               | 赋值              |

- 指令集与运行时间模型
  - 基本RISC指令集
  - 完全RISC附加指令
- 操作最右侧
- 公式1：将一个字的最右侧的1位改为0位
  - `x&x(x-1)`
  - 若没有1位则生成所有位为0的字
  - 用途：
    - 1.检测一个无符号整数是否为2的幂（需要0-检测）
- 公式2：检测一个无符号整数是否为$2^n-1$的形式
  - `x&(x+1)`
- 公式3：
  - 析出isolate最右侧1位：`x&(-x)`
  - 析出最右侧0位：`~x&(x+1)`
- 公式4：识别后缀0的掩码
  - `~x&(x-1)` （具有指令并行）
  - `~(x|-x)`
  - `(x&-x)-1`
- 公式5：识别最右侧1位和后缀0的掩码
  - `x^(x-1)`
- 公式6：向右传播最右侧1位
  - `x|(x-1)`
- 公式7：将右侧连续1位串改为0位串
  - `((x|(x-1))+1)&x`
- 对偶性
  - 用x+1替换x-1
  - 用~(x+1)替换-x
  - 用& 替换 |
  - 用|替换&
  - x和~x不变
- 命题：如何判断对于一个给定的函数是否能用一系列的加、减、与、或、非指令实现？
- 定理：
  - **将字映射到字的函数可以使用字的加、减、与、或、非指令实现，当且仅当函数的结果的每一位只依赖于每个输入操作数的相应位以及相应位的右侧的位**
  - 原因：事实倒置：加、减、与、或、非函数都是可以按照从右到左方式计算
- 题目：对于给定的代表子集的数字x,寻找x中最右侧连续1位以及后面0位，递增x到下一个具有相同数目的1位的值，Eg：xxx0 1111 0000变为xxx1 0000 0111
- HAK算法：

```C
int x=0b0001110100;
int s = x &-1; //识别x中
int r = x +s;
int e = x^r;
e = (e>>2)/s;
int y = r|e;
```

- 结合逻辑操作的加运算
  - 恒定式
  - -x =~x+1 =~(x-1)
  - ~x =-x-1
  - -~x=x+1
  - ~-x=x-1
  - x+y=x-~y-1 = (x^y)+2(x&y) = (x|y)+(x&y) = 2(x|y)-(x^y)
  - x-y=x+~y+1 = (x^y)-2(~x&y) =(x&~y)-(~x&y) = 2(x&~y)-(x^y)
  - x^y = (x|y)-(x&y)
  - x&~y=(x|y)-y = x-(x&y)
  - ~(x-y)=y-x-1 = ~x+y
  - x==y =(x&y)-(x|y)-1 = (x&y)+~(x|y)
  - x|y = (x&~y)+y
  - x&y = (~x|y)-~x
- 逻辑和算术表达式中的不等式
  - $(x|Y) >= max(x,y)$
  - $(x&y) <= min(x,y)$
  - $(x|Y) <= x+y (无和溢出)$
  - $(x|Y) > x+y (和溢出)$
  - $|x-y| <=(x^y)$
- 绝对值函数
  - 可以使用3-4个无分支的指令完成绝对值指令

| abs(x-y) | nabs(x-y) |
| -------- | --------- |
| (x^y)-y  | y-(x^y)   |
| (x+y)^y  | (y-x)^y   |
| x-(2x&y) | (2x&y)-x  |

注：2x = x + x = x<<1

- 符号扩展
  - 指定一个字中的某位为符号位，将符号位向左传播，忽略其他位
  - 标准做法：先逻辑左移，然后带符号右移
  - EG：向左传播第7位,获得第7位取反后的所有低位，然后减去第7位为1的数
  - $((x+0x00000080)&0x000000FF) - 0x00000080$
  - $((x&0x000000FF)^0x000000FF) - 0x00000080$
- 用无符号右移实现带符号右移
  - $((x+0x8000 0000)>>n) - (0x8000 0000 >>n)$
  - $t=0x8000 0000 >> n;((x>>n)^t)-t$
  - $t=(x&0x8000 0000)>>n;(x>>n)-(t+t)$
  - $t=-(x>>31);((x^t)>>n)^t$
  - $(x>>n)|(-(x>>31)<<31-n)$
  - $0x8000 0000 >>n <==> 1<<31-n$
- 符号函数

$$
sign(x) =
\begin{cases}
        -1, &x<0\\
        0 , &x=0\\
        1 , &x>0\\
\end{cases}
$$
- 基本指令实现：
  - $sign(x) = (x>>^s31)|(-x>>^u31)$
  - $只对x=-2^{31}失败$
- 三值比较函数

$$
cmp(x,y)=
\begin{cases}
    -1,&x<y\\
    0,&x=y\\
    1,&x>y\\
\end{cases}
$$
- 基本指令实现：
  - $(x>y)-(x<y)$
  - $(x>=y)-(x<=y>)$

- 符号传递

$$
ISIGN(x,y)=
\begin{cases}
  abs(x),&y>0\\
  -abs(x),&y<0\\
\end{cases}
$$
- 基本指令实现：
