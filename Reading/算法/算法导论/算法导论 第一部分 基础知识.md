# 算法导论 第一部分 基础知识

## 第一章 算法在计算中的应用

- 什么是算法 algorithm
- 数据结构
- NP完全问题
- 作为一种技术的算法
  - 1.算法的效率计算与衡量

## 第二章 算法基础

### 循环不变式

- 循环不变式的三条性质：
  - 1.初始化：循环第一次迭代前为真；
  - 2.保持：若某次迭代前为真，则下次迭代前仍为真；
  - 3.终止;循环终止时，不变式提供有用的性质，证明算法正确性；

### 伪代码约定

- 1.缩进表示块结构
- 2.循环结构：while，for,repeat-until;条件结构：if-else;
- 3.注释：//
- 4.数组访问：数组名\[下标\],从1开开始，到N

### 算法的分析

- 假定模型：RAM
- 运行时间分析

### 算法设计

- 增量方法：插入排序:$O(n^2)$；
- 分治法：归并排序:$O(n\log_2{n})$；

#### 插入排序算法

```C
#include <stdio.h>
//插入排序算法
void InsertSort(int a[]){
    int i=0;
    whi(a[i]!='\0'){
        int key =a[i];
        int j = i-1;
        while(j>=0&&a[j]>key){
            a[j+1] = a[j];
            j--;
        }
        a[j+1] = key;
        i++;
    }
}
```

#### 归并排序算法

```C
#include <stdio.h>
#include <limits.h>
void Merge(int[] a,int p,int q,int r){
    int llen = q-p;
    int rlen = r-q+1;
    int L[llen+1];
    int R[rlen+1];
    for(int i=0;i<llen;i++){
        L[i] = a[p+i];
    }
    for(int i=0;i<rlen;i++){
        R[i] = a[q+i];
    }
    L[llen]=INT_MAX;
    R[rlen]=INT_MAX;
    int i=0;
    int j=0;
    for (int k = p-1; k <r;k++){
        if(L[i]<R[j]){
            a[k]=L[i];
            i++;
        }
        else{
            a[k]=R[j];
            j++;
        }
    }
}
void Merge-Sort(int[] a,int p,int r){
    if(p<r){
        int q=(p+r)/2;
        Merge-sort(a,p,q);
        Merge-sort(a,p+1,r);
        merge(a,p,q,r);
    }
}
```

## 第三章 函数的增长

### 渐进记号

- 渐进为正：
- 渐进紧缺界：
- $f(n) = \Theta (g(n)) \{f(n):存在正常量c_0,c_1,存在n_0>0,当n>n_0时,有0 \leq c_0g(n) \leq f(n) \leq c_1g(n)\}$
- 渐进上界：
- $f(n) = O (g(n)) \{f(n):存在正常量c,存在n_0>0,当n>n_0时,有0 \leq f(n) \leq cg(n)\}$
- 渐进下界：
- $f(n) = \Omega (g(n)) \{f(n):存在正常量c,存在n_0>0,当n>n_0时,有0 \leq cg(n) \leq f(n)$
- `定理`:$对任意的两个函数f(n) g(n),若f(n)=\Theta (g(n)) ,当且仅当f(n) = O(g(n))且f(n) = \Omega (g(n))$
- 非渐进紧缺的上界：
- $f(n) = o(g(n))\{f(n):对任意正常量c,存在n_0>0,当n>n_0时,有0 \leq f(n) < cg(n)\}$
- 非渐进紧缺的下界：
- $f(n) = \omega(g(n))\{f(n):对任意正常量c,存在n_0>0,当n>n_0时,有0  \leq cg(n) < f(n) \}$
- 性质：
  - 传递性:
  - 自反性:
  - 对称性:
  - 转置对称性：

### 标准记号与常用函数

- 概念：单调性、向上取整、向下取整、模运算、多项式、指数、对数、阶乘、多重函数、斐波那契数列、黄金分割
  $$a>1: n^b = o(a^n) $$
  $$ e^x = 1 + x+ \frac{x^2}{2!}+ \cdots + \frac{x^n}{n!} = \sum_{i=0}^{\infty}{\frac{x^i}{i!}} \qquad e^x = 1 + x + \Theta(x^2) \qquad \lim_{n \to \infty}{(1 + \frac{x}{n})^n} = e^x $$
  $$\lg{n} = \log_2{n} \qquad \ln{n} = \log_e{n} \qquad a^{\log_b{c}} = c^{\log_b{a}} $$
  $$ \ln(1 + x) = x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots + (-1)^{n-1}\frac{x^n}{n}  \qquad x>-1,\frac{x}{1+x} \leq \ln(1 + x) < x \qquad \lg^bn = o(n^n)$$
  $$n! = \sqrt{2\pi n}(\frac{n}{e})^n(1 + \Theta(\frac{1}{n})) \qquad n! = o(n^n) \qquad n! = \omega(2^n) \qquad \lg(n!) = \Theta(n\lg{n})$$
  $$ n \geq 1,n! = \sqrt{2\pi n}(\frac{n}{e})^ne^{\alpha_n} , \frac{1}{12n+1} < \alpha_n < \frac{1}{12n}$$
  $$多重函数：f^{(i)}(n) = \begin{cases} n,& \text{ i = 0 } \\ f(f^{(i-1)}(n)), & \text{ i > 0 }\end{cases} $$
  $$多重对数函数：\lg^*n  \qquad 定义： \lg^*n = min\{i \geq 0:lg^{(i)}n \leq 1\} (解释：为多重函数\lg^{(i)}n结果小于等于1时的最小i值)$$
  $$增长非常缓慢：\lg^*2 = 1 \qquad \lg^*4 = 2 \qquad \lg^*16 = 3 \qquad \lg^*65536 = 4 \qquad \lg^*{2^{65536}} = 5 $$

### 渐进标记总结

| 函数                                           | 条件    |
| ---------------------------------------------- | ------- |
| $n = \Theta{(1)}$                              |         |
| $c_0n^a+c_1n^{a-1}+\cdots+ c_a= \Theta{(n^a)}$ | $a>0$   |
| $n^a = o{(n^b)}$                               | $b>a>0$ |
| $n^b = o(a^n)$                                 | $a>1$   |
| $n! = o(n^n)$                                  |         |
| $n! = \omega{(2^n)}$                           |         |
| $\lg{ n!} = \Theta{(n\lg{n})}$                 |         |
| $\lg^b{n} = o(n^n)$                            |         |
| $\ln{(1+n)} = o(n)$                            | $n>-1$  |
| $\ln{(1+n)} = \omega{(\frac{n}{1+n})}$         | $n>-1$  |

## 第四章 分治策略

- 分治策略的步骤：分解-解决-合并**DCC**,Divide-Conquer-Combine
- 递归式-Recurrence
- 三种求递归式的方法：
  - 1.代入法：猜测界-数学归纳法
  - 2.递归树法：转换为一颗树
  - 3.主方法：递归公式：$T(n) = aT(n/b)+f(n)$
- 两个问题：
  - 1.求解最大子数组问题；
  - 2.求解$n \times n$矩阵乘法问题；
- 最大子数组问题Maximum Subarray:
  - 问题分析:
  - 问题变换:
  - 求解策略:
  - 算法分析：暴力破解：$\Theta(n^2)$,分治算法:$\Theta(n\lg{n})$
- 矩阵乘法Strassen算法:
  - 矩阵基础算法：
    - $$C = A \cdot B \qquad {c_{ij} =\sum_{k=1}^{n}{a_{ik}\cdot b_{kj}}}$$
    - 时间：$T(n) = \Theta(n^3)$
  - 简单归并算法：
    - 1.分解矩阵：A,B,C 分解为12个$n/2 \times n/2$的子矩阵;
    - 2.递归计算子矩阵乘法,得到8个子结果矩阵;
    - 3.相加结果矩阵得到结果矩阵C的子矩阵;

```伪代码
Square_Matrix_Multiply_Recursive(A,B)
    n = A.rows
    let C be a new n-n matrix
    if n==1
        c11=a11 * b11
    else partition A,B,C as in equations
        C11 = Square_Matrix_Multiply_Recursive(A11,B11)+Square_Matrix_Multiply_Recursive(A12,B21)
        C12 = Square_Matrix_Multiply_Recursive(A11,B12)+Square_Matrix_Multiply_Recursive(A12,B22)
        C21 = Square_Matrix_Multiply_Recursive(A21,B11)+Square_Matrix_Multiply_Recursive(A22,B21)
        C22 = Square_Matrix_Multiply_Recursive(A21,B12)+Square_Matrix_Multiply_Recursive(A22,B22)
    return C
```

- 算法分析：
  - 运行时间：$T(n) = \Theta(n^3)$

 $$T(n) =
 \begin{cases}
 \Theta(1),& n=1 \\
 8T(n/2)+\Theta(n^2),&n>1
 \end{cases}$$

- **Strassen算法**
  - 1.分解矩阵：A,B,C分解为n/2子矩阵;
  - 2.创建10个子矩阵$S_i，S_i为步骤1子矩阵的加减所得$;
  - 3.通过$S_i$子矩阵的运算，递归计算7个矩阵积$P_i$;
  - 4.通过$P_i$矩阵的不同运算，计算结果矩阵C的子矩阵$C_{11},C_{12},C_{21},C_{22}$

$$T(n) =
 \begin{cases}
 \Theta(1),& n=1 \\
 7T(n/2)+\Theta(n^2),&n>1
 \end{cases}$$

- 运行时间：$T(n) = \Theta(n^{\lg7}) \qquad 2.80<\lg7<2.81$
- 细节揭示：

$$
\begin{aligned}
Step1:\\
&A=\begin{vmatrix}
    A_{11} &A_{12} \\
    A_{21} &A_{22} \\
\end{vmatrix}\qquad
B=\begin{vmatrix}
    B_{11} &B_{12} \\
    B_{21} &B_{22} \\
\end{vmatrix}\qquad
C=\begin{vmatrix}
    C_{11} &C_{12} \\
    C_{21} &C_{22} \\
\end{vmatrix}\\
Step2:\\
& S_1 =B_{12} - B_{22} \qquad S_2 =A_{11} + A_{12}\\
& S_3 =A_{21} + A_{22} \qquad S_4 =B_{21} - B_{11}\\
& S_5 =A_{11} + A_{22} \qquad S_6 =B_{11} + B_{22}\\
& S_7 =A_{12} - A_{22} \qquad S_8 =B_{21} + B_{22}\\
& S_9 =A_{11} - A_{21} \qquad S_{10} =B_{11} + B_{12}\\
Step3:\\
& P_1 = A_{11}\cdot S_{1}  \qquad P_2 = S_{2} \cdot B_{22}\\
& P_3 = S_{3} \cdot B_{11} \qquad P_4 = A_{22}\cdot S_{4}\\
& P_5 = S_{5} \cdot S_{6}\\
& P_6 = S_{7} \cdot S_{8}\\
& P_7 = S_{9} \cdot S_{10}\\
Step4:\\
& C_{11} = P_5 + P_4 - P_2 + P6\\
& C_{12} = P_1 + P_2\\
& C_{21} = P_3 + P_4\\
& C_{22} = P_5 + P_1 - P_3 - P7\\
\end{aligned}
$$

```伪代码
Square_Matrix_Multiply_Strassen(A,B)
    n = A.rows
    if n==10
        C11=a11*B11
    else partition A,B,C as in equations
        S1 = B12 - B22
        S2 = A11 + A12
        S3 = A21 + A22
        S4 = B21 - B11
        S5 = A11 + A22
        S6 = B11 + B22
        S7 = A12 - A22
        S8 = B21 + B22
        S9 = A11 - A21
        S10 = B11 + B12
        P1 = Square_Matrix_Multiply_Strassen(A11,S1)
        P2 = Square_Matrix_Multiply_Strassen(S2,B22)
        P3 = Square_Matrix_Multiply_Strassen(S3,B11)
        P4 = Square_Matrix_Multiply_Strassen(A22,S4)
        P5 = Square_Matrix_Multiply_Strassen(S5,S6)
        P6 = Square_Matrix_Multiply_Strassen(S7,S8)
        P7 = Square_Matrix_Multiply_Strassen(S9,S10)
        C11 = P5 + P4 - P2 + P6
        C12 = P1 + P2
        C21 = P3 + P4
        C22 = P5 + P1 - P3 - P7
    return C
```

