# LRU Latest Recently Used 近期最少使用算法

- 参考资料
> https://www.cnblogs.com/-OYK/archive/2012/12/05/2803317.html
> https://www.cnblogs.com/dolphin0520/p/3749259.html

## LRU

### 原理

- 算法根据数据的历史访问记录来进行淘汰数据，“若数据最近被访问过，则将来被访问的几率更高”

### 实现

- 仅需要一个缓存数据队列
- 使用链表保存缓存数据
- 新数据插入链表的头部
- 每当缓存命中时，将数据移到链表头部
- 当链表满时，淘汰链表尾部的数据

### 分析

- 命中率
  - 存在热点数据时，LRU效率较高；偶发性以及周期数据时LRU命中率下降，缓存污染较严重
- 复制度
  - 实现简单
- 代价
  - 命中：遍历链表，找到数据块索引，将数据移到头部

## LRU-K

### 原理

- LRU-K中K：最近使用次数，主要是用于解决LRU算法的缓存污染问题，核心：判断标准扩展为“最近使用过K次”

### 实现

- 需要一个缓存数据队列，一个访问历史队列
- 数据第一次被访问，加入访问历史队列；
- 若数据在访问历史队列后，访问次数未达到K次，则按照一定规则（FIFO，LRU）淘汰；
- 若数据在访问历史队列后，访问次数达到K次，则将数据索引从历史队列删除，将数据移动到缓存队列中，按照时间排序缓存队列；
- 缓存数据队列被访问后，重新按照时间排序；
- 缓存队列淘汰数据，淘汰队列末尾的数据，即淘汰“倒数第K次访问距离现在最久的”的数据；

### 分析

- 命中率：一般使用LRU-2，LRU-3或者更大K值命中率更高，但适应性差；
- 复杂度：优先级队列，复杂度较高；
- 代价：内存消耗和CPU比较高；

## Tow Queues (2Q)

### 原理

- 类似LRU-2，不同：将历史访问队列改变为FIFO缓存队列，即两个缓存队列，FIFO队列，LRU队列

### 实现

- 当数据第一次访问时，将数据放到FIFO的缓存队列中，当数据第二次访问时，将数据放入LRU队列中，每个队列按照自己的规则淘汰数据
- 新访问的数据插入FIFO队列；
- 若数据在FIFO队列中没有被再次访问,则按照FIFO规则淘汰；
- 若数据在FIFO队列中再次被访问，则将数据移入LRU队列头部；
- 若数据在LRU队列中再次被访问，则将数据移入LRU队列头部；
- LRU队列淘汰末尾数据；

### 分析

- 命中率：2Q命中率高于LRU
- 复杂度：需要两个队列：FIFO队列，LRU队列；
- 代价：内存消耗与LRU接近

## Multi Queue (MQ)

### 原理

- 根据访问频率将数据划分为多个队列，不同队列具有不同的优先级，核心：优先缓存访问次数多的数据

### 实现

- 将缓存划分为多个LRU队列，每个队列对应不同的访问优先级，访问优先级根据访问次数定义
- Q0,Q1,Q2..Qk表示k个不同优先级的队列，Q-h表示从缓存中淘汰的数据，Q-h记录数据索引和引用次数队列
- 1.新插入数据放入Q0；
- 2.每个队列按照LRU管理数据；
- 3.当数据访问次数达到一定次数时，需要提升优先级，将数据从当前队列删除，加入高优先级队列；
- 4.需要淘汰数据时，从最低级队列按照LRU进行淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-h队列头部；
- 5.若数据在Q-h队列中被重新访问，则重新计算其优先级，移到目标队列的头部；
- 6.Q-h按照LRU淘汰数据的索引；

### 分析

- 命中率：比LRU高
- 复杂度：需要维护多个队列，维护每个数据的访问时间
- 代价：需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU高；

对比分析：
LRU
LRU-2
2Q
MQ(2)