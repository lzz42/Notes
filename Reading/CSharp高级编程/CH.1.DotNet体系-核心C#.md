# C#高级编程

## 01 DotNet体系

### 1..NET Framework

- 包括：运行环境（运行时）和类库
- 运行环境提供.net应用程序所需的核心服务，主要：内存分配、清理服务
- 运行环境-公共语言基础结构CLI-Common Language Infrastructure
- 规范性：主要定义了可执行代码和运行环境的规范；
- CLR
- 公共语言运行时（Common Language Runtime）-确保应用程序符合安全规则，并为应用程序提供资源；
- 微软专用的运行环境CLR遵循标准就是CLI；
- VES
- 运行环境-Virtual Execution System
- CTS
- CLI的核心组成-通用类型系统（Common Type System），定义编程语言的类型和操作规范；
- CLS
- 公共语言规范-（Common Language Specification）-提供高级语言互操作的规范；
- Managed Code
- 托管代码-通过.net编写的程序；
- CIL
- 托管代码通过公共中间语言（Common Intermediate Language ）和文件格式进行传输和存储
- 所有的源代码语言都要编译成CIL指令集。MSIL-Microsoft实现的CIL；
- 托管数据由CLR自动分配和释放，存储在托管堆上（managed heap），通过垃圾回收机制自动释放数据。
- 托管堆（managed heap）
- 应用程序第一次启动，CLR为该应用程序预留一块内存即托管堆
- 堆：带有内存基址的一块内存区。内存区连续，存储区按线性方式分配，垃圾回收

- 泛型约束
- 1.where T:struct 结构约束    T必须是值类型,必须在其他所有约束之前，与class不能共用
- 2.where T:class  类型约束    T必须是引用类型，必须在其他所有约束之前，与struct不能共用
- 3.where T:IFoo   接口预算    T必须实现IFoo接口
- 4.where T:Foo    基类约束    T必须继承自基类Foo
- 5.where T:new()  构造约束    T必须具有默认的new()构造函数（这里仅限于默认构造函数），必须为最后一个约束,且不能与struct约束共用
- 6.where T1:T2    裸类型约束   T1必须派生自泛型T2
- 约束合并
- eg：where T:Foo,IFoo1,new()

- 协变和抗变（逆变）
- 指对参数和返回值的类型转换
- net中参数类型是协变的
- 参数不能 父类->子类 但是可以 子类->父类
- 即Func(ClassA ca,ClassB cb) 传值时 Func(ClassAA caa,ClassBB cbb) ClassAA:ClassA ClassBB:ClassB
- 即可以传递派生自基类的任何对象作为参数
- 方法的返回值总是抗变的 返回值不能 父类->子类 但是可以 子类->父类
- 若 ClassAA() 可以返回 ClassA 
- 即可以返回 返回类型的子类的任何对象 
- 即父类不一定转换为子类，但子类一定可以转换为父类
- C#4 支持 泛型接口 和 泛型委托 的协变和抗变
- 对于泛型接口
- 参数使用out标注 表示该参数是协变的
- 返回值使用in标注 表示该返回值是抗变的
- nullable<T>--解决结构为空问题
- 可空泛型（结构泛型）
- 1.泛型约束：泛型类型必须为结构类型，不能为类类型（类本身为引用类型可空，而结构为值类型不能为空）
- 2.强制类型转换：Nullable转换为T显示；T转换为Nullable为隐式；
- 引申 定义可空类型变量
- 使用？定义
- eg：以下都是可空的int类型

```C#
 Nullable<int> x1;
 int? x2;
```

- 类型转换：
- 非可空类型总是可以转换为可空类型，且为隐式转换并且总是能够成功
- 可空类型转换为非可空类型可能会失败，若可空类型为null时，则转换失败，所以需要显式强制转换；
- 另一种方式就是（即不使用显式强制转换）使用合并运算符进行转换，为转换定义默认值
- 合并运算符(coalescing operator) ?? 
- 泛型方法
- 1.泛型方法可以定义在非泛型类中
- 2.泛型方法可以重载，但不能根据泛型约束不同重载，可以根据泛型类型数量不同重载
- 但不可以指定in out
- in out 只适用于泛型接口或泛型委托
- 编译器调用时有限匹配最佳方法，即有限使用非泛型匹配的方法，其他类型则使用泛型方法，这个是在编译期间调用的，不是运行期间
- 即编译时使用哪个方法匹配，运行时就使用哪个方法匹配；-> 泛型方法调用泛型方法问题，运行时不会出现泛型内调用非泛型匹配方法
- 注意：编译期间调用 与 运行期间调用
- 创建某个类型的第一个实例时,所进行的操作顺序为:
    1.静态变量设置为0
    2.执行静态变量初始化器
    3.执行基类的静态构造函数
    4.执行静态构造函数
    5.实例变量设置为0
    6.执行衯变量初始化器
    7.执行基类中合适的实例构造函数
    8.执行实例构造函数
    同样类型的第二个以及以后的实例将从第五步开始执行.
- 数组
  - 1.数组是一种数据结构
  - 2.数组是引用类型
  - 3.初始化后数组大小不能改变，不同于集合
  - 4.预定义类型数组，自定义类型数组
  - 5.若数组中的元素是引用类型，则必须为每个元素分配内存
  - 6.多维数组 与 锯齿数组
  - 7.Array类抽象数组类
- 数组复制
  - 1.数组为引用类型，若直接复制将会得到对同一个数组对象（地址）的两个引用
  - 2.复制数组实现ICloneable接口,实现数组的 浅表副本 复制
  - 3.若数组元素为值类型，则Clone()方法复制所有的值
  - 4.若数组元素为引用类型，则Clone()方法只复制元素的引用而不复制元素本身
- 对比Clone()和Copy()
  - 同：都是创建数组的浅表副本
  - 异：Clone()会创建新的数组，而Copy()必须传递阶数相同且有足够元素的数组
- 若创建数组的深层副本，就必须迭代数组并创建新对象
- 数组排序
  - 1.数组内元素使用QuickSort算法对元素进行排序;
  - 2.Sort()方法需要数组中的元素实现ICompareable接口;
  - 3.自定义的数组元素必须实现ICompareable接口；
- ICompareable、ICompareable<T>接口
- 接口方法 int CompareTo(Object)、int CompareTo(T);
- 说明：若实例与参数对象相同，返回0；若实例在参数对象前面则返回值小于0；若实例在参数对象后面则返回值大于0；
- IComparer或者IComparer<T>接口
- 若数组元素类不能修改或排序方式不同，则需要实现IComparer或者IComparer<T>接口
- 接口方法 int Compare(Object,Object)、int Compare(T,T)
- 说明：返回值与ICompareable类似
- 数组参数 与 数组协变
  - 1.函数参数、返回值均可定义为数组类型
  - 2.数组支持协变，即可以将数组声明为基类,将其派生类元素赋予数组
  - 3.协变只能用于引用类型，不能用于值类型
- 数组段 ArraySegment<T> 
  - 1.数组的一段，通过（原数组，偏移量，元素个数）初始化
  - 2.数组段不复制原数组元素，但可以通过ArraySegment<T>访问原数组，若数组段元素改变则会相应的反映到原数组中
- yield
- 使用迭代快，C#编译器会生成yield类型，其中包含状态值，yield类型实现IEnumerator和IDisposeable接口，或者其泛型版本
- yield语句会生成一个枚举器
- 类支持的默认迭代是返回IEnumerator的GetEnumerator()方法，命令返回IEnumerable
- 用yield return 返回枚举器
- 元组
- 区别与数组
  - 1.数组合并相同类型对象，元组合并不同类型对象
  - 2..Net4定义了8个泛型Tuple类和一个静态Tuple类，作为元组的工厂，不同的泛型Tuple类支持不同数量元素
  - 3.元组使用静态类Tuple的静态Create方法创建
  - 4.可以使用Item1、Item2、。。。访问元组元素
  - 5.如果元素的元素项超过8个，可以使用8个参数的Tuple类定义，最后一个模板参数为TRest,TRest必须传递一个元组
- 结构比较-数组和元组
  - 1.数组和元组都实现接口IStructuralEquatable, IStructuralComparable，且都为显式实现, IComparable
  - 2.IStructuralEquatable  比较两个数组或元组是否拥有相同的内容
  - 3.IStructuralComparable 用于给元组或者数组排序

#### 运算符-operator

- 1.sizeof -> * & 值能用于不安全代码 unsafe{}
- 2.运算符的简化
- 3.条件运算符 condition？true：false;
- 4.checked 和unchecked
  - checked { } CLR 执行溢出检查
  - unchecked { } CLR 不执行溢出检查
  - unchecked 是默认行为
- 5.is运算符 用于检查该对象是否与特定类型兼容
  - 兼容：是该类型、该类型的派生类
- 6.as执行类型的显示转换，若类型兼容则成功，否则返回null
  - 可以不需要is测试类型兼容性
- 7.sizeof用于确定栈中值类型需要的长度，单位字节
- 对于复杂类型以及非基元类型，sizeof需要放在unsafe{}下执行
- 8.typeof 返回一个表示特定类型的system.Type对象
- 利用反射查找对象相关信息
- 9.可空类型和运算符
- int？
- 10.空合并运算符 ？？
- 处理可空类型和引用类型时，表示null可能的值
- 运算符使用 int？ res = a??b;
- 要求：b必须与a类型相同或者可以隐式转换为a类型
- 计算：若a不是null则结果res为a值；若a为null则res为b值；
- 11.运算符优先级
- 初级运算符 > 一元运算符 > 乘除运算符 > 加减运算符 > 移位运算符 > 关系运算符 > 比较运算符 
- > &(AND) > ^(XOR) > |(OR) > && > || > 条件运算符(?:) > 赋值运算符
- 注：复杂表达式避免使用运算符优先级生成结果，最好使用（）
  - 初级运算符：(),[],sizeof,typeof,X++,X--,new,checked,unchecked
  - 一元运算符：+,-,!,~,++x,--X,数据类型强制转换
  - 乘除运算符:*,/,%
  - 移位运算符：<<,>>
  - 关系运算符: <,>,>=,<=,as,is
  - 赋值运算符：=,+=,-=,*=,/=,&=,|=,^=,>>=,<<=,>>>=

#### 类型的安全性

- 1.类型转换
- 类型隐式转换
- 保证值不发生任何变化
- 原则：
  - 1.只能从较小的整数形式转换为较大的整数形式，浮点类型，有符号类型特殊处理
  - 2.可空类型隐式转换为其他可空类型
  - 3.非可空类型隐式转换为可空类型
  - 4.可空类型不能隐式转换为非可空类型
  - 5.demical不能隐式转换为其他整型或者浮点类型，因为demical内部结构不同
- 显式转换
- 可以使用cast显式转换
- Type A = (Type)B;
- 可以使用checked检测算术溢出
- double b;
- int a = checked((int)b);
- 比较对象相等性
- 区分引用类型和值类型（基元类型，结构类型，枚举实例）
- 1.比较引用类型
  - system.Object 类定义了ReferenceEquals()和两个版本的Equals() 以及相等运算符（==）
- 1.1 bool ReferenceEquals(object,object)
  - 静态方法，测试两个引用是否引用类的同一个实例，即两个引用是否包含相同的内存地址,相同返回true，否则返回false
- 1.2 virtual bool Equals(object)
  - 可以重写，从而按值比较对象。特别若希望类的实例作为字典中的键，就需要重写该方法,重写的Equals内代码不会抛出异常
- 1.3 static bool Equals(object,object)
  - 静态方法，处理两个对象有null的情况下，
  - 若都为null，则返回true，若只有一个为null，则返回false，若都不为null，则返回虚函数Equals
  - 比较运算符（==）
  - 严格的值比较与严格引用比较中间项，一般情况表示比较引用
- 2.比较值类型相等
- 与比较引用类型类似:
- ReferenceEquals()比较引用；
- Equals()比较值
- 比较运算符中间项
- 不能对结构重载==运算符
- Equals()默认比较地址，值类型中存在引用需要重写Equals()
- 运算符重载
- 编译器知道所有常见运算符对于数据类型的含义。
- 1.运算符的工作方式
- 即编译器遇到运算符是如何处理
  - 1.根据参数类型查找该运算符最匹配的重载，注预定义的返回类型不会影响编译器对重载方法的选择；
  - 2.若找不到匹配项在报错
- 2.运算符重载
- public static returns operator opeartors (pars[]);
- 若为二元运算符，则第一个参数表示运算符左边的参数命名为lhs，第二个参数表示运算符右边的参数rhs
- 要求：运算符重载必须声明为public 和static 即应该与特定的实例无关，而只与类或者结构相关，其代码不能访问非静态成员或者被this引用
- 编译器不会颠倒参数顺序
- C#不允许=重载，-=，+=，*=，/=，&=，|=等没有重载
- 比较运算符重载：
- C#要求
  - 1.若重载了==则必须重载!=，>和<，<=和>=都必须成对重载；
  - 2.必须重载system.Object 继承的Equals()和GetHasCode(),原因:Equals()应实现与“==”相同类型的相等逻辑；
  - 3.比较运算符必须返回bool类型；
  - 4.不要通过System.Object的中个Equals()实例版本，重载比较运算符，会出现null.Equals(objectB)异常
- 浅度比较与深度比较
  - 浅度比较：比较对象是否指向内存中的同一位置；
  - 深度比较：比较对象的值和属性是否相等；
- 并非所有的运算符都可以重载
  - 赋值运算符不能显式重载；
  - `[]索引运算符不能直接重载--索引器成员支持索引运算符[]`
  - `()数据类型转换运算符--不能直接重载，用户定义的类型强制转换允许定制强制转换运算符`
- 比较运算符必须成对重载
- 按位一元运算符（！，~，true，false）--true和false必须成对重载
- 隐式类型转换
  > public static implicit operator [type]([params])
- 显式类型转换
  > publc staic explicit operator [tye]([params])
- 用户定义的类型强制转换
- 1.首先应遵循预定义类型都类型强制转换原则：
  - 若无论源如何，类型强制转换总是安全的，则声明为隐式转换--implicit
  - 若可能会出错、丢失数据、抛出异常，则应声明为显式转换--explicit
  - 同样需要声明为 public static implicit/explicit ...
- 1.类之间的类型强制转换
- 限制：
  - 1.派生类之间不能定义类型强制转换（本身已经存在）
  - 2.类型强制转换必须在源类型（结构）或者目标类型（结构）内部定义
  - 3.对于每一种转换只能有一种类强制转换
- 2.基类与派生类之间类强制转换
- 派生类可以隐式的转换为基类，因为对于基类的任何引用都可以引用基类的对象或任何派生自基类的对象
- 基类转换为派生类，通常在派生类中添加基类实例参数的构造函数
- 3.装箱与拆箱
- 基本结构与派生结构之间的强制转都是基元型或结构与system.Object之间的转换
- 结构到object 隐式是装箱
- 具体过程：
  - 1.在定义结构时，.NET Framework会隐式的提供另一个类即装箱的该类，该类包含与当前结构完全相同的字段，但是是引用类型，存储在堆上；
  - 2.隐式的将该结构实例强制转换为Object时，就会实例化一个该结构的装箱类，并使用该结构数据初始化
  - 3.从而对于Object的引用其实就是该实例化的装箱类的引用
- 拆箱
  - 就是将装箱类的数据复制到一个新的该结构中。
- 装箱 拆箱 都是把数据复制到新装箱类或者新拆箱的对象中。
- 4.多重类型转换
  - 若不存在直接类型转换，存在隐式或者显示类型转换
  - 多重类型转换
  - eg：目标：A->D，但不存在直接A到D的转换，
  - 而是存在A->B,B->C（隐式），C->D(隐式)，
  - 则可以A->D进行强制转换
- 委托
- 寻址方法的.NET版本，类型安全类，定义了返回类型和参数类型
- 1.声明委托
- 即定义委托，定义时必须指明所表示方法的返回值、签名等
- 给方法的返回值和签名类型指定名称
- delegate void FuncCallBack();
- 定义位置：
- 委托是一个新类，可以在定义类的任何地方定义委托
- 委托实现派生自基类System.MulticastDelegate类，System.MulticastDelegate类派生自基类System.Delegate
- 在C#中委托总是可以接受一个参数的构造函数，该参数为委托引用的方法，此方法必须匹配委托定义时的签名
- 在任何代码中都应提供委托实例的名称
- 委托推断
- 减少输入量，只传递地址名称
- 只能把方法的地址赋予委托变量（应不含括号）
- 类型安全，确保被调用的方法签名正确，但不关心在什么类型对象上使用该方法，以及该方法是否为静态方法
- 给定委托的实例可以引用任何类型的对象上的实例方法或者静态方法，只要方法的签名匹配与委托的签名(参数修饰符必须一致)
- Action<T>和Func<T>委托
  - 泛型Action<T>委托表示引用返回void的方法，存在不同变体，最多存在16种不同类型的参数，但不存在没有参数的方法
  - 泛型Func<T>委托表示引用带返回类型的方法，存在不同变体，最多存在16种不同类型的参数，Func<out result>可允许调用带返回值且无参数的方法
  - eg:Func<T,K,TResult> 最后一个参数总为返回值
-多播委托
  - 一个委托只包含一个方法调用，多个方法调用需要多个委托
  - 多播委托：一个委托包含多个方法，按照一定顺序连续调用多个方法，委托签名必须为void否则将只会得到最后一个方法的返回值
  - 实际上：多播委托派生自类System.MultiCastDelegate类（该类派生自System.Delegate）该类其他成员允许把多个方法的调用链接为一个列表
  - 支持“+”、“+=”、“-”、“-=”运算，即列表添加或者删除函数调用
- mark：
  - 1.方法执行顺序，对于同一个委托的方法调用顺序并未定义，所以避免依赖于方法的顺序产生结果
  - 2.方法异常，若执行委托的方法的过程中抛出异常，则之后的所有方法都将不会执行调用（即委托迭代会停止），解决应自己迭代委托执行
- Delegate类型定义了，GetInvocationList()方法，该方法返回一个Delegate对象数组，可以迭代执行此数组，处理异常
- eg：Delegate[] delegates = Objet.GetInvocationList();
  - foreach(Action a in delegates){ ... }
- 匿名方法
  - 匿名方法委托参数的一段代码
  - 代码执行不是很快，编译器自动指定一个匿名方法的名称
- 遵循原则：
  - 1.匿名方法不能跳转到匿名方法外部
  - 2.匿名方法的外部不能跳转到匿名方法内部
  - 3.匿名方法内部不能访问不安全代码，不能使用ref、out
- 可以使用Lambda表达是代替匿名方法
- Lambda表达式
- 三部分组成
- 1.放在括号中的参数列表
- 2.=>运算符
- 3.C#语句
- C#编译器会提取=>后的代码，创建一个匿名方法
- 参数：
  - 1.可以通过类型推断确定参数类型，也可以定义参数类型
- 字符串string
- string映射System.String类型，
- System.Text和System.Text.RegularExpressions
  - 1.创建字符串---可以考虑使用System.Text.StringBulider
  - 2.格式化表达式---使用接口IFormatProvider和IFormattable处理
  - 3.正则表达式---识别字符串、提取子字符串System
- System.String类
- 1.string类常用方法
  - Compare、CompareOriginal、Contact、CopyTo、Format、IndexOf、IndexOfAny、Insert、Join、LastIndexOf、
  - LastIndexOfAny、PadLeft、PadRight、Replace、Split、SubString、Trim、ToLower、ToUpper
- 2.创建字符串
  - 重复修改字符串，效率很低。
  - string为不可变的数据类型，一旦初始化该对象就不能再改变
  - StringBuilder类仅限对字符串进行替换、追加、删除、修改处理  
  - （需引用namespace：System.Text）
  - StringBuilder类属性：Length-字符串的实际长度；Capacity-字符串分配在内存的最大长度；
  - 初始化时指定内存初始容量，在内存中操作，若内存不够，则自动进行容量翻倍
  - StringBuilder成员：
  - 1.构造函数可以指定字符串或容量，也可以设置MaxCapacity最大容量
- 3.格式化字符串
  - .NET定义标准方式：IFormattable接口
  - 格式说明符{obj,len:FormatStr}    eg:{0,10:E}
  - 格式化过程：传递给格式化函数，对象，格式说明符
  - 1.首先检查该对象是否实现了IFormattable接口（使用is关键字测试或者强制转换测试）；
  - 2.若测试失败则执行该对象的ToString()方法；
- IFormattable接口
  - 只有一个方法string ToString(string,IFormatProvider);