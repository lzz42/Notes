# 装载与动态链接

## 6.可执行文件的装载与进程

### 6.1 进程的虚拟地址空间

- 程序与进程的区别？
  - 程序是静态概念，是一个预编译好的指令和数据的集合的文件
  - 进程是动态概念，是程序运行的过程
- 进程的虚拟地址空间大小和可用范围问题：
  - 虚拟地址空间大小取决于硬件CPU位数确定，即寻址能力
  - 程序角度，即依据指针所占的空间范围计算虚拟地址空间
  - 使用范围：整个指针可访问的范围 去掉操作系统的占用部分
- 如何扩展程序的使用空间，即扩展指针可访问的常规范围?
  - PAE:物理地址扩展，使用操作系统提供的窗口映射方法，根据需要将同一块虚拟内存映射到多个不同的内存

### 6.2 装载的方式

- 覆盖装载:覆盖管理器
  - 将程序进行分块，并决定何时该块被加载和替换，调用目标必须在内存中程序才能执行
- 页映射：映射管理器
  - 将内存和磁盘中的数据按照页进行分割，实现以页为单位的数据加载
  - 页置换算法：LUR

### 6.3 从操作系统看可执行文件的装载

- 进程建立
  - 1.创建独立的虚拟地址空间
    - 虚拟空间：一组页函数将各个页映射到相应的物理空间，创建虚拟地址空间实质为创建映射函数所需的数据结构
  - 2.读取可执行文件，建立虚拟地址空间与可执行文件的映射
    - 可执行文件与页的映射关系：ELF文件段与页映射问题
    - VMA 虚拟内存区域（VMA）或虚拟段：虚拟空间中的一个段
  - 3.将CPU寄存器设置为可执行文件的入口地址
- 页错误
  - 进程建立后，真正的指令和数据并没有加载到内存中，仅仅是建立映射关系，
  - 当CPU根据入口地址开始执行指令时，根据映射关系查找虚拟页
  - 若该页为空（即未加载数据），CPU将控制权交给操作系统，操作系统查询虚拟映射数据结，查找空页面VMA，计算页在可执行文件中的偏移，物理内存分配物理页面并与虚拟页建立映射，加载数据
  - 继续执行原CPU指令，随着指令执行不断出现页错误，操作系统不断进行处理，因此出现虚拟内存管理

### 6.4 进程虚拟存储空间分布

- ELF文件链接视图和执行视图
- ELF文件映射单位：系统的页长度（每个段的映射时长度都是系统也长度的整数倍，若不是整数倍多余部分也将占用一个页）
- 多个不同长度的段出现导致内存空间浪费问题
- ELF文件段长度大小不一，读写权限不一
- 方案一：
  - 相同权限的段，合并到一起进行页映射，成为一个段，Segment，（注意：此处合并后的每个段的长度也不一定是系统也长度的整数倍，即仍存在内存空间浪费的问题）
  - ELF文件是按照Segment存储
  - ELF可执行文件中含有一个专门用于保存Segment信息的数据结构：程序头表Program Header Table，Elf32_Phdr,类似于段表
  - 查看ELF文件的段(Segment):`readelf -S a.elf`
- 链接视图：`Section划分ELF`
- 执行视图：`Segment划分ELF`
- 针对"段"：
  - 装载时，段指Segment
  - 其他情况下指Section
- 堆和栈
  - 通常，一个进程中的堆和栈 分别对应一个VMA
  - 匿名虚拟内存区域：指没有映射到ELF文件中的VMA，通常指Heap\Stack\vdso
  - vdso:内核模块(位于内核空间)
- VMA类型划分：
  - 代码( 指令、程序)VMA：只读、可执行、有文件映射
  - 数据VMA：读写、可执行、有文件映射
  - 堆VMA：读写、可执行、无文件映射，匿名，向上扩充
  - 栈VMA：读写、不可执行、无文件映射，匿名，向下扩充
- [堆最大申请数量](./6.loading_process.c)
- 段地址对齐
  - 原因：操作系统通过虚拟内存的页映射完成可执行文件的加载，页映射中，页是最小单位
  - 在映射时，即将一段物理内存与虚拟内存建立映射关系，内存空间的长度必须是页大小的整数倍，而且映射的起始地址也必须是页大小的整数倍
  - 限制：映射空间的长度、映射空间的起始地址
  - 简单的映射方式：每个段(segment)分别映射,长度不足一个页的仍占有一个页，对于多个段仍存在较多的内存碎片
  - UNIX改进：各个段的接壤部分共享同一个页，然后系统将该共享也分两次映射，并且将ELF文件头看做是一个段（segment）
  - 段必须是4字节的整数倍
  - 规律：`在ELF文件中，对于任何一个可装载的Segment，p_vaddr除以对齐属性的余数等于p_offset除以对齐属性的余数`
- 进程栈的初始化
  - 进程开始启动时，需要知道进程运行的环境（系统环境变量和进程运行参数）
  - 常见做法：将环境信息提前保存到进程空间的栈中 Stack VMA
  - main()函数中的argc,argv参数值的由来

### 6.5 Linux内核装载ELF过程

- Linux bash输入命令执行某个ELF程序
- 1.（用户层面）bash进程调用fork()系统调用，创建一个新进程，新进程调用execve()系统调用执行指定的ELF文件，原bash进程等待新进程结束
- 2.execve()系统调用定义在unistd.h中，函数原型：`int execve(const char * filename,char *const argv[],char *const envp[])`,三个参数：程序文件名、执行参数、环境变量
- 3.进入execve()系统调用后，Linux内核开始进行装载工作：调用sys_execve()：进行参数检查复制，调用do_execve():查找可执行文件，若找到文件则读取前128字节（用于判断文件格式），调用search_binary_handle():搜索和匹配合适的可执行文件装载处理程序并调用相应的装载处理程序（针对ELF文件为load_elf_binary()）
- 4.load_elf_binary()处理过程：
  - a.检查ELF文件的有效性
  - b.寻找动态链接的".introp"段，设置动态链接器路径
  - c.根据ELF文件的程序头表的描述，对ELF文件进行映射
  - d.初始化ELF进程环境
  - e.将系统调用的返回地址修改为ELF文件的入口点（对于静态链接ELF文件，入口点为文件头中的e_entry所指地址，对于动态链接ELF文件入口地址为动态链接器）
- 5.load_elf_binary()执行完毕，返回do_execve(),然后返回sys_execve(),此时系统调用的返回地址已修改为被装载的ELF程序的入口地址
- 6.sys_execve()系统调用从内核态返回用户态时，EIP寄存器直接跳转到ELF程序的入口地址，并开始执行，即ELF文件装载完成

### 6.6 Windows PE的装载

- PE与ELF文件的不同：所有段的起始地址都是页的整数倍，段长度不是页整数倍时，映射时向上补齐到页的整数倍（PE文件中段数量较少）
- RVA（Relative Virtual Address）:相对虚拟地址，相对于PE文件装载的基地址的偏移地址
- 每个PE文件在装载时都会有一个装载目标地址即基地址（RVA的基地址）：绝对地址= 基地址+RVA，基地址是每次装载都是不同的但是RVA是固定的
- PE文件装载过程
  - 1.读取文件的第一个页，该页包含：DOS头、PE文件头、段表
  - 2.检查进程地址空间，目标地址是否可用（不可用是另选目标地址，主要是DLL装载）
  - 3.使用段表提供的信息将PE文件中的段映射到地址空间中
  - 4.若装载地址不是目标地址，则进行Rebasing
  - 5.装载所有PE文件所需的DLL文件
  - 6.对PE文件中的所有导入符号进行解析
  - 7.根据PE头指定的参数，建立初始化堆和栈
  - 8.建立主线程并启动进程
- PE扩展头装载相关的成员属性介绍

### 6.7 总结

- 1.进程虚拟地址空间的概念和意义
- 2.程序装载方式介绍
- 3.进程的建立与程序的装载关联，VMA
- 4.进程的虚拟地址空间分布，段的内存映射方案、堆与栈VMA、段地址对齐、进程栈的初始化
- 5.Linux装载ELF的过程
- 6.Windows PE装载的过程

## 7.动态链接

### 7.1 动态链接的意义

- 动态链接的优点：
  - 节省内存空间（共享指令和数据），减少物理页的换入换出：多进程操作系统中，静态链接浪费内存空间
  - 灵活的程序更新和发布：只需更新变动个模块即可
  - 动态链接：对于需要的目标文件仅在需要时进行链接
  - 程序的可扩展性和兼容
- 动态链接的基本实现：
  - 