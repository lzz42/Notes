# 第二部分 排序和顺序统计学

- 排序问题
  - 输入：长度为n的序列$<a_1,a_2,a_3,...,a_n>$
  - 输出：长度为n的有序序列$<a_1',a_2',...,a_n'>,a_1' \leq a_2' \leq ... \leq a_n'$
- 排序算法
  - 比较排序算法：
    - 插入排序：$最坏情况\Theta(n^2),内循环紧凑的原地排序算法$
    - 合并排序：$最坏情况\Theta(n\lg{n})$
    - 堆排序：$\Theta(n\lg{n}),原地排序$
    - 快速排序：$最坏情况\Theta(n^2),平均情况\Theta(n\lg{n}),内循环紧凑的原地排序算法$
  - 非比较排序算法
    - 计数排序
    - 基数排序
    - 桶排序
- 顺序统计学
  - 在一个由n个数组成的集合中，第i个顺序统计是集合中第i小的数

## 06 堆排序

- heapsort,运行时间为$n\lg{n}$的原地排序算法
- 算法设计：利用某种数据结构来管理算法执行中的信息

### 6.1 堆

- 二叉堆数据结构（完全二叉树）
  - 最大堆：`A[Parent[i]] >= A[i]`
  - 最小堆：`A[Parent[i]] <= A[i]`
- Max_Heapify:$\Omicron(\lg{n})$，保持堆的性质
- Build_Max_Heap:$\Omicron(n)$
- Heap_Sort:$\Omicron(\lg{n})$

### 6.2 保持堆的性质

```C
int parent(int i){
    return math.floor(i/2);
}
int left(int i){
    return 2*i;
}
int right(int i){
    return 2*i+1;
}

void max_heapify(int* a,int i,int len){
    int l = left(i);
    int r = right(i);
    int largest =i;
    if(l <=heap_size(a) && a[l] >a[i){
        largest =l;
    }
    if(r <=heap_size(a)&& a[r]>a[largest]){
        largest = r;
    }
    if(largest!=i){
        swap(a[i],a[largest]);
        max_heapify(a,largest,len);
    }
}

void min_heapify(int* a,int i,int len){
    int l = left(i);
    int r=right(i);
    int littlest =i;
    if(l <=heap_size(a) && a[l] <a[i){
        littlest =l;
    }
    if(r <=heap_size(a)&& a[r]<a[littlest]){
        littlest = r;
    }
    if(littlest!=i){
        swap(a[i],a[littlest]);
        min_heapify(a,littlest,len);
    }
}
```

### 6.3 建堆

```C
void build_max_heap(int* a,int len){
    int c = math.floor(len/2);
    for(int i=c;i>=0;i--){
        max_heapify(a,i,len);
    }
}
```

- 前提:子数组$A[\lfloor n/2 \rfloor+1,...,n]$都树的叶子，通过叶子节点自底向上的调用保持堆性质函数构建堆
- 紧缺界的确定：一个n元素的堆高度为$\lfloor \lg{n} \rfloor$，在任意高度h上，最多有$\lceil n/2^{h+1} \rceil$个节点
- 由此可计算构建堆的时间界为：$\Omicron(n)$

### 6.4 堆排序

```C
void heap_sort(int* a,int len){
    build_max_sort(a,len);
    for(int i=len-1;i>1;i--){
        swap(a[1],a[i]);
        heap_size(a)=heap_size(a) -1;
        max_heapify(a,1);
    }
}
```