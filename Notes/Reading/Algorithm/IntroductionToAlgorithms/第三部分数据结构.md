# 第三部分 数据结构

- 动态集合的元素
  - 关键字、卫星数据
- 动态集合的操作
  - 查询操作:`x Search(S,k)、x Minimum(S)、x Maximum(S)、x SuccessOr(S,x)、x PredecessOr(S,x)`
  - 修改操作:`void Insert(S,x)、void Delete(S,x)`

## 10 基本数据结构

### 10.1 栈和队列

- 栈Stack LIFO
  - 入栈Push\出栈Pop
- 队列Queue FIFO
  - 入队InQueue\出对DeQueue

### 10.2 链表

- 单链表
- 双向链表
  - 哨兵元素
- 循环链表

### 10.3 指针和对象的实现

- 在没有显示指针类型的情况下实现链式数据结构
- 对象的多数组表示
  - 每个属性使用一个数组表示
  - eg：节点对象`Key[x],Value[x],Next[x],Prve[x]`
- 对象的单数组表示
- 对象的分配与释放
  - 自由表：保存自由对象的单链表

### 10.4 有根树的表示

- 二叉树
  - Parent/Left/Right
- 分支无限的有根树
  - 左孩子右兄弟表示法：Parent/LeftChild/RightSibling
- 二叉树的遍历
  - 先序遍历、中序遍历、后序遍历

## 11 散列表

- 散列表Hash Table：动态集合结构，不直接使用关键字作为数组下标，而是根据关键字计算相应的下标
- 散列表冲突：不同的关键计算得到相同的下标问题
- 处理散列表冲突方法

### 11.1 直接寻址表

- 使用数组存放数据，每个关键词都对应于一个下标
- 缺点：空间浪费问题

### 11.2 散列表

- 槽的位置，依据散列函数$h(k)$计算所得，即$h:全域U \rightarrow 散列表T$
- 冲突collision:两个不同的关键字映射到同一个槽
- 散列函数：对于同一个值每次计算都映射到同一个槽，对于不同的值，尽量减少冲突
- 通过链接法解决冲突：
  - 散列函数映射到同一个槽中的所有元素，放到一个链表中
  - 性能分析：$装载因子(一个链的平均存储元素数)\alpha = \frac{n}{m},n:最大元素数量，m：槽数量$
  - 最坏查找情况：$\Theta(n)$
  - 假设均匀散列映射：$E[n_j]=\alpha=\frac{n}{m}$
  - $`11.1 在均匀散列的假设下，使用链接法解决冲突的散列表，一次不成功的查找的平均时间为：\Theta(1+\alpha)`$
  - $`11.1 在均匀散列的假设下，使用链接法解决冲突的散列表，一次成功的查找的平均时间为：\Theta(1+\alpha)`$

### 11.3 散列函数

- 散列函数特点：
  - 1.满足均匀散列假设，每个关键词等可能的映射到m个槽的任何一个
  - 2.散列值某种程度上应独立于数据可能存在的任何模式
- 将关键字转换为自然数
- 除法散列算法
  - $h(k)= k \pmod{m}$
  - m选择：m值应避免选某些值，最好是不接近2的整数幂的素数
- 乘法散列法
  - $h(k) =\lfloor m(kA \pmod {1}) \rfloor = \lfloor m(kA - \lfloor{kA}\rfloor) \rfloor, 0 < A <1$
  - 关键字k * 常数A = r,m * (r小数部分)，向下取整
  - m选择：一般为2的某个幂次
- 全域散列法
  - 随机选择散列函数