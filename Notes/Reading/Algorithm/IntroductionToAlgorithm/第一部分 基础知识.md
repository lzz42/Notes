# 第一部分 基础知识

- 算法导论

## 第一章 算法在计算中的应用

- 什么是算法 algorithm
- 数据结构
- NP完全问题
- 作为一种技术的算法
  - 1.算法的效率计算与衡量

## 第二章 算法基础

### 循环不变式

- 循环不变式的三条性质：
  - 1.初始化：循环第一次迭代前为真；
  - 2.保持：若某次迭代前为真，则下次迭代前仍为真；
  - 3.终止;循环终止时，不变式提供有用的性质，证明算法正确性；

### 伪代码约定

- 1.缩进表示块结构
- 2.循环结构：while，for,repeat-until;条件结构：if-else;
- 3.注释：//
- 4.数组访问：数组名\[下标\],从1开开始，到N

### 算法的分析

- 假定模型：RAM
- 运行时间分析
- 时间复杂度：最坏情况运行时间

### 算法设计

- 增量方法：插入排序:$O(n^2)$；
- 分治法：归并排序:$O(n\log_2{n})$
  - 分治模式：
    - 分解Divide
    - 解决Conquer
    - 合并Combine

#### 插入排序

```C
//插入排序算法
void InsertSort(int* a,int len)
{
    int i = 1;
    while (len>0)
    {
        int key = a[i];
        int j = i - 1;
        while (j >= 0 && a[j] > key)
        {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = key;
        i++;
        len--;
    }
}
```

```C#
void InsertSort(int[] a)
{
  if(a==null || a.Length<2)
    return;
  for(int i = 1;i<a.Length;i++)
  {
    int key = a[i];
    for(int j=i-1;j>=0 && a[j]>key;j--)
    {
      a[j+1]=a[j];
    }
    a[j+1]=key;
  }
}

```

#### 归并排序算法

```C
//p<=q<r
//合并子数组a[p,q],a[p+1,r]
//p<=q<r
//合并子数组a[p,q],a[p+1,r]
void Merge(int *a, int p, int q, int r)
{
    int k = 0;
    int *ret = (int *)malloc((r - p + 1) * sizeof(int));
    for (k = p; k <= r; k++)
    {
        ret[k - p] = a[k];
    }
    int i = 0;
    int j = q - p + 1;
    for (k = p; k < r + 1; k++)
    {
        if (i == q + 1 - p)
        {
            a[k] = ret[j];
            j++;
            continue;
        }
        if (j == r + 1 - p)
        {
            a[k] = ret[i];
            i++;
            continue;
        }
        if (ret[i] < ret[j])
        {
            a[k] = ret[i];
            i++;
        }
        else
        {
            a[k] = ret[j];
            j++;
        }
    }
    free(ret);
}
void MergeSort(int *a, int p, int r)
{
    if (p < r)
    {
        int q =(p + r) / 2;
        MergeSort(a, p, q);
        MergeSort(a, q + 1, r);
        Merge(a, p, q, r);
    }
}
void MergeSortIn(int *a, int len)
{
    MergeSort(a, 0, len - 1);
}
```

## 第三章 函数的增长

### 渐进记号

- 渐进为正：
- 渐进紧缺界：
- $f(n) = \Theta (g(n)) \{f(n):存在正常量c_0,c_1,存在n_0>0,当n>n_0时,有0 \leq c_0g(n) \leq f(n) \leq c_1g(n)\}$
- 渐进上界：
- $f(n) = O (g(n)) \{f(n):存在正常量c,存在n_0>0,当n>n_0时,有0 \leq f(n) \leq cg(n)\}$
- 渐进下界：
- $f(n) = \Omega (g(n)) \{f(n):存在正常量c,存在n_0>0,当n>n_0时,有0 \leq cg(n) \leq f(n)$
- `定理`:$对任意的两个函数f(n) g(n),若f(n)=\Theta (g(n)) ,当且仅当f(n) = O(g(n))且f(n) = \Omega (g(n))$
- 非渐进紧缺的上界：
- $f(n) = o(g(n))\{f(n):对任意正常量c,存在n_0>0,当n>n_0时,有0 \leq f(n) < cg(n)\}$
- 非渐进紧缺的下界：
- $f(n) = \omega(g(n))\{f(n):对任意正常量c,存在n_0>0,当n>n_0时,有0  \leq cg(n) < f(n) \}$
- 性质：
  - 传递性:
  - 自反性:
  - 对称性:
  - 转置对称性：

### 标准记号与常用函数

- 概念：单调性、向上取整、向下取整、模运算、多项式、指数、对数、阶乘、多重函数、斐波那契数列、黄金分割
  $$a>1: n^b = o(a^n) $$
  $$ e^x = 1 + x+ \frac{x^2}{2!}+ \cdots + \frac{x^n}{n!} = \sum_{i=0}^{\infty}{\frac{x^i}{i!}} \qquad e^x = 1 + x + \Theta(x^2) \qquad \lim_{n \to \infty}{(1 + \frac{x}{n})^n} = e^x $$
  $$\lg{n} = \log_2{n} \qquad \ln{n} = \log_e{n} \qquad a^{\log_b{c}} = c^{\log_b{a}} $$
  $$ \ln(1 + x) = x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots + (-1)^{n-1}\frac{x^n}{n}  \qquad x>-1,\frac{x}{1+x} \leq \ln(1 + x) < x \qquad \lg^bn = o(n^n)$$
  $$n! = \sqrt{2\pi n}(\frac{n}{e})^n(1 + \Theta(\frac{1}{n})) \qquad n! = o(n^n) \qquad n! = \omega(2^n) \qquad \lg(n!) = \Theta(n\lg{n})$$
  $$ n \geq 1,n! = \sqrt{2\pi n}(\frac{n}{e})^ne^{\alpha_n} , \frac{1}{12n+1} < \alpha_n < \frac{1}{12n}$$
  $$多重函数：f^{(i)}(n) = \begin{cases} n,& \text{ i = 0 } \\ f(f^{(i-1)}(n)), & \text{ i > 0 }\end{cases} $$
  $$多重对数函数：\lg^*n  \qquad 定义： \lg^*n = min\{i \geq 0:lg^{(i)}n \leq 1\} (解释：为多重函数\lg^{(i)}n结果小于等于1时的最小i值)$$
  $$增长非常缓慢：\lg^*2 = 1 \qquad \lg^*4 = 2 \qquad \lg^*16 = 3 \qquad \lg^*65536 = 4 \qquad \lg^*{2^{65536}} = 5 $$

### 渐进标记总结

| 函数                                           | 条件    |
| ---------------------------------------------- | ------- |
| $n = \Theta{(1)}$                              |         |
| $c_0n^a+c_1n^{a-1}+\cdots+ c_a= \Theta{(n^a)}$ | $a>0$   |
| $n^a = o{(n^b)}$                               | $b>a>0$ |
| $n^b = o(a^n)$                                 | $a>1$   |
| $n! = o(n^n)$                                  |         |
| $n! = \omega{(2^n)}$                           |         |
| $\lg{ n!} = \Theta{(n\lg{n})}$                 |         |
| $\lg^b{n} = o(n^n)$                            |         |
| $\ln{(1+n)} = o(n)$                            | $n>-1$  |
| $\ln{(1+n)} = \omega{(\frac{n}{1+n})}$         | $n>-1$  |

## 第四章 分治策略

- 分治策略的步骤：分解-解决-合并 **DCC**,Divide-Conquer-Combine
- 递归式-Recurrence
- 三种求递归式的方法：
  - 1.代入法：猜测界-数学归纳法
  - 2.递归树法：转换为一颗树
  - 3.主方法：递归公式：$T(n) = aT(n/b)+f(n)$
- 两个问题：
  - 1.求解最大子数组问题；
  - 2.求解$n \times n$矩阵乘法问题；
- 最大子数组问题Maximum Subarray:
  - 问题分析:
  - 问题变换:
  - 求解策略:
  - 算法分析：暴力破解：$\Theta(n^2)$,分治算法:$\Theta(n\lg{n})$
- $n \times n$矩阵乘法:
  - 矩阵基础算法：
    - $$C = A \cdot B \qquad {c_{ij} =\sum_{k=1}^{n}{a_{ik}\cdot b_{kj}}}$$
    - 时间：$T(n) = \Theta(n^3)$
  - 简单归并算法：
    - 1.分解矩阵：A,B,C 分解为12个$n/2 \times n/2$的子矩阵;
    - 2.递归计算子矩阵乘法,得到8个子结果矩阵;
    - 3.相加结果矩阵得到结果矩阵C的子矩阵;
    - 运行时间：$T(n) = \Theta(n^3)$
    $$T(n) =
    \begin{cases}
    \Theta(1),& n=1 \\
    8T(n/2)+\Theta(n^2),&n>1
    \end{cases}$$
  - **Strassen算法**
    - 1.分解矩阵：A,B,C分解为n/2子矩阵;
    - 2.创建10个子矩阵$S_i，S_i为步骤1子矩阵的加减所得$;
    - 3.通过$S_i$子矩阵的运算，递归计算7个矩阵积$P_i$;
    - 4.通过$P_i$矩阵的不同运算，计算结果矩阵C的子矩阵$C_{11},C_{12},C_{21},C_{22}$
    $$T(n) =
    \begin{cases}
    \Theta(1),& n=1 \\
    7T(n/2)+\Theta(n^2),&n>1
    \end{cases}$$
    - 运行时间：$T(n) = \Theta(n^{\lg7}) \qquad 2.80<\lg7<2.81$
    - 细节揭示：
    $$
    \begin{aligned}
    Step1:\\
    &A=\begin{vmatrix}
        A_{11} &A_{12} \\
        A_{21} &A_{22} \\
    \end{vmatrix}\qquad
    B=\begin{vmatrix}
        B_{11} &B_{12} \\
        B_{21} &B_{22} \\
    \end{vmatrix}\qquad
    C=\begin{vmatrix}
        C_{11} &C_{12} \\
        C_{21} &C_{22} \\
    \end{vmatrix}\\
    Step2:\\
    & S_1 =B_{12} - B_{22} \qquad S_2 =A_{11} + A_{12}\\
    & S_3 =A_{21} + A_{22} \qquad S_4 =B_{21} - B_{11}\\
    & S_5 =A_{11} + A_{22} \qquad S_6 =B_{11} + B_{22}\\
    & S_7 =A_{12} - A_{22} \qquad S_8 =B_{21} + B_{22}\\
    & S_9 =A_{11} - A_{21} \qquad S_{10} =B_{11} + B_{12}\\
    Step3:\\
    & P_1 = A_{11}\cdot S_{1}  \qquad P_2 = S_{2} \cdot B_{22}\\
    & P_3 = S_{3} \cdot B_{11} \qquad P_4 = A_{22}\cdot S_{4}\\
    & P_5 = S_{5} \cdot S_{6}\\
    & P_6 = S_{7} \cdot S_{8}\\
    & P_7 = S_{9} \cdot S_{10}\\
    Step4:\\
    & C_{11} = P_5 + P_4 - P_2 + P6\\
    & C_{12} = P_1 + P_2\\
    & C_{21} = P_3 + P_4\\
    & C_{22} = P_5 + P_1 - P_3 - P7\\
    \end{aligned}
    $$

- 递归式的求解方法
  - 代入法：猜测一个边界然后使用数学归纳法证明此边界的正确性
  - 递归树：将递归式转换为一颗树，结点表示不同层次的递归调用的代价，采用边界和技术求解
  - 主方法：$T(n)=aT(n-1)+f(n),a\geq 1,b>1,f(n)为给定的函数，生成a个子问题，每个子问题的求解规模为原问题的1/b，分解与合并的花费时间总和f(n)$

### 4.3 使用代入法求解递归式

- 分两步：
  - Step1 猜测解的形式
  - Step2 用数学归纳法求解中常数，证明解的正确；
- 注意：
  - 1.要求边界条件成立
  - 2.猜测：可以从较松的上下界，逐渐缩小不确定范围；
  - 3.从猜测界减去较低项
  - 4.证明结果需与归纳假设一致
  - 5.变量代换

### 4.4 使用递归树求解递归式

- 递归树调用总代价T：计算每层的代价和，计算所有层的代价和；
- 举例：$T(n) = 3T(n/4) + \Theta(n^2)$
- $T(n) = 3T(n/4) + cn^2$
- 第0层代价：$cn^2$
- 第一层代价：$c(\frac{n}{4})^2 \qquad c(\frac{n}{4})^2 \qquad c(\frac{n}{4})^2$
- 最后一层：$T(1)$
- 分析：
  - 1.问题规模每一步减少上一步规模的四分之一：深度为i的子节点对应问题规模为:$n/4^i,最底层问题规模为1，即n/4^i=1,因此总深度为：i = \log_4{n} + 1$
  - 2.问题每一层的节点数都是上一层的3倍，因此第k层总节点数为：$3^k,且深度为i的每个节点的代价为：c(n/4^i)^2,因此深度为i层的所有节点总代价为：3^ic(n/4^i)^2$
  - 3.整颗树总代价：

$$
\begin{aligned}
T(n) & = cn^2 + \frac{3}{16}cn^2+(\frac{3}{16})^2cn^2+\cdots+(\frac{3}{16})^{\log_4{n}-1}cn^2+\Theta(n^{\log_43})\\
     & = \sum_{i=0}^{\log_4{n}-1}(\frac{3}{16})^icn^2 + \Theta(n^{\log_43})\\
     & = \frac{(3/16)^{\log_4{n}}-1}{(3/16)-1}cn^2 + \Theta(n^{\log_43}) < \sum_{i=0}^{\infty}(\frac{3}{16})^icn^2 + \Theta(n^{\log_43})\\
     & = \frac{1}{1- (3/16)}cn^2 + \Theta(n^{\log_43})\\
     & = \frac{16}{13}cn^2 + \Theta(n^{\log_43})\\
     & = O(n^2)\\
\end{aligned}
$$

### 4.5 使用主方法求解递归式

- 递归式形式：$T(n) = aT(n/b)+f(n),a \geq 1,b>1,f(n)为渐进正函数$
- 描述：
  - 将规模为n的问题分解为a个子问题，每个子问题的规模为n/b,a个子问题递归求解，花费时间为T(n/b);f(n)表示问题分解和问题合并的代价
- `主定理`：

$$
T(n) = aT(n/b) + f(n)\\
令a \geq 1,b>1,f(n)为一个函数，T(n)定义在非负整数上的递归式\\
其中n/b解释为[n/b]，向上取整或向下取整;\\
T(n)=
\begin{cases}
\Theta(n^{\log_b{a}}) &1.若对某个常数\epsilon>0,有f(n)=O(n^{\log_b{a} - \epsilon})\\
\Theta(n^{\log_b{a}}\lg{n}) &2.若f(n) = \Theta(n^{\log_b{a}})\\
\Theta(f(n)) &3.若对某个常数\epsilon>0,有f(n)=O(n^{\log_b{a} + \epsilon}),且对某个常数c>0和足够大的n有af(n/b) \leq cf(n)\\
\end{cases}
$$

- 注意：在情况1和情况2之间的一定间隙 和 情况2和情况3之间的一定间隙 不能使用主定理
- EG:
  - $T(n) = 9T(n/3) + n,适用于情况1，T(n) = \Theta(n^2)$
  - $T(n) = T(2n/3) + 1,适用于情况2，T(n) = \Theta(\lg{n})$
  - $T(n) = 3T(n/4) + n\lg{n},适用于情况3，T(n) = \Theta(n\lg{n})$
  - $T(n) = 2T(n/2) + n\lg{n},不适用于任何情况，在情况2和3之间$

### 4.6 主定理的证明

## 第五章 概率分析和随机算法

### 5.1 雇佣问题和指示器随机变量

- 定义：
  - 随机算法：算法的行为不仅由输入决定，而且也由随机数生成器产生的数值决定
  - 指示器随机变量、样本空间、期望值$E[X]$、发生概率$Pr\{X\}$

$$
I\{A\} =
\begin{cases}
&1 \qquad 如果A发生\\
&0 \qquad 如果不A发生\\
\end{cases}
$$

- 引理：$一个事件A对应的指示器随机变量的期望值等于事件A发生的概率$
- 引理5.2：$假设应聘者以随机次序出现，算法Hire-Assistant的总雇佣费用平均情形下为:(c_h\ln{n}),E(x)=\sum_{i=1}^{n}{1/i}$

```C
Hire-Assistant(n)
    best = 0
    for i = 0 to n
        interview candidate i
        if candidate i is better than candidate best
            best = i
            hire candidate i
```

### 5.3 随机算法

```C
Randomize-Hire-Assistant(n)
    rendomly permute the list of candidates
    best =0 //candidates 0 is least-qualified dummy candidate
    for i = 0 to n
        interview candidate i
        if candidate i is better than candidate best
            best = is
            hire candidate i
```

- 概率分析和随机算法的区别
  - 引理5.3：$过程Randomize-Hire-Assistant的总雇佣费总期望为:O(c_h\ln{n})$
  - 5.2引理与5.3引理的区别：
    - 5.2 在输入上进行假设，5.3没有，而是采用随机化输入
    - 5.2 采用平均情形下的雇佣费用，5.3 采用期望雇佣费用
- 随机排列数组
  - 目标：将给定1-n的数组构造为1-n的的随机数组
  - 方法：
    - Permute-by-Sorting:给每一个元素赋予一个随机的优先级，然后按照优先级进行排序
    - 原址排列给定数组：

```C
Permute-By-Sorting(A)
    n = A.length
    let P[1..n] be a new array  
    for i = 0 to n
        P[i] = Random(1,n^3)
    sort A,Using P as Sort Keys
```

- 均匀随机排列:等可能的产生1-n的每一种排列；
- n元素的k排列(k-permutation):n个元素中的k个元素的子序列，并且不重复，共有n!/(n-k)!种可能;

```C
Randomize-In-Place(A)
    n = A.length
    for i = 0 to n
        swap A[i] with A[Random(i,n)]
```

- 问题：
  - 1.如何证明一个随机算法是可以产生均匀随机排列？
  - 2.如何设计一个可以产生均匀随机排列的随机算法？

### 5.4 概率分析和指示器随机变量的进一步应用

#### 生日悖论

- 解决如何确定k个人中，至少有某两人生日相同的概率。
- 前提：一年总天数n=365，假设生日均匀分布于全年
- 基本概率分析：

$$
某人b_i生日在某天r的概率为：P_r\{b_i = r\}=\frac{1}{n} \\
两人生日在某天r的概率为:P_r\{b_i=r\ and\ b_j=r\}=\frac{1}{n^2}\\
两人生日在同一天概率：P_r\{b_i=b_j\}=\sum_{r=1}^{n}{P_r\{b_i=r\ and\ b_j=r\}}=\sum_{r=1}^{n}{\frac{1}{n^2}}=\frac{1}{n}\\
$$

- 概率分析求解：

$$
采用事件补方法，k个人至少有两人同一天生日的概率 = 1 - k个人生日都不同的概率B_k，\\
B_k = \bigcap_{i=1}^{k}A_i,A_i指对于所有j<i,i与j不同生日的事件\\
B_k = A_i \bigcap B_{k-1},因此:P_r\{B_k\} = P_r\{B_{k-1}\}P_r\{A_k|B_{k-1}\} \\
P_r\{B_1\} = P_r\{A_1\} = 1,且P_r\{A_k|B_{k-1}\} = \frac{n-k+1}{n}\\
\begin{aligned}
P_r\{B_k\}
& = P_r\{A_k|B_{k-1}\}\\
& = P_r\{B_{k-2}\}P_r\{A_{k-1}|B_{k-2}\}P_r\{A_k|B_{k-1}\}\\
& = 1 \cdot (\frac{n-1}{n}) \cdot (\frac{n-2}{n}) \cdots (\frac{n-k+1}{n})
& = 1 \cdot (1 - \frac{1}{n})(1 - \frac{2}{n})\cdots (1 - \frac{k-1}{n})
\end{aligned}\\
由1+x \leq e^x,P_r\{B_k\} \leq e^{-1/n}e^{-2/n}\cdots e^{-(k-1/n)} = e^{-\sum_{i=1}^{k-1}{i/n}} = e^{-k(k-1)/2n} \leq 1/2\\
即:k(k-1) \geq 2n\ln{2}\\
对于：n=365，求解得:k \geq 23
$$

- 指示器随机变量求解：

$$
k个人的每一对(i,j),对于1 \geq i < j \geq k,定义指示器随机变量X_{ij}:\\
X_{ij} = I\{i,j生日相同\} = 
\begin{cases}
& 1 \quad 若i,j生日相同\\
& 0 \quad 其他
\end{cases}\\
E[X_{ij}] = P_r\{i,j生日相同\} = 1/n\\
定义X表示计数生日相同两人对数目的随机变量，\\
X = \sum_{i=1}^{k}\sum_{j=i+1}^{k}X_{ij}\\
E[X] = \frac{k(k-1)}{2n}\\
令期望数至少为1则k=28
$$

#### 球与箱子

- 问题：需要投多少次球，才能使每个箱子里至少有一个球？b个箱子
- 前提：每次投球独立，每次投球，等可能落入每一个箱子
- 解决：
定义命中：一次投球落入一个空箱子，称为一次命中；即b次命中所需投球次数n;<br>
n次投球划分b个阶段，第i个阶段包括从第i-1次命中到第i次命中所需的投球数，第i阶段每次投球有i-1个非空箱子，b-i+1个空箱子，命中概率为(b-i+1)/n;<br>
则
$$
E[n_i] = \frac{b}{b-i+1};\\
由期望的线性性质：\\
E[n] = E[\sum_{i=1}^{b}{n_i}] = \sum_{i=1}^{b}{n_i} \\
= \sum_{i=1}{b}{\frac{b}{b-i+1}} = \sum_{i=1}^{b}{\frac{1}{i}} = b(\ln{b}+O(1))
$$

- 礼券收集者问题：若想要收集b种不同的礼券中的每一种，大约需要 $b\ln{b}$ 张随机礼券.

#### 特征序列

- 问题：抛一枚标准硬币n次，最长连续正面的序列的期望长度是多少？A:$\Theta (\lg{n})$
- 证明：

$$
令A_{ik}为长度至少为k的正面特征序列开始于第i次抛掷事件，即第i,i+1,i+2,\cdots ,i+k-1次都是正面，\\
1 \leq k \leq n,1 \leq i \leq n-k+1\\
P_r\{A_{ik}\} = \frac{1}{2^k}\\
取k \lg n 向上取整,[\lg n],\quad
P_r\{A_{i,[\lg n]}\} = \frac{1}{2^{[\lg n]}} \leq \frac{1}{2^{\lg n}} = \frac{1}{n^2}\\
i的起始位置数量：n-2[\lg n]+1个，长度至少为2[\lg n]的正面特征序列开始于任一位置的概率：\\
P_r\{ \bigcup_{i=1}^{n-2[\lg n]+1}{A_{i,2[\lg n]}} \} \leq \sum_{i=1}^{n-2[\lg n]+1}{\frac{1}{n^2}} < \sum_{i=1}^{n}{\frac{1}{n^2}} = \frac{1}{n}\\
由布尔不等式：一组事件并集的概率最多是各个事件的概率之和;\\
最长特征序列长度L，概率：E[L] = 
$$