# 你必须知道的.Net

## 1.面向对象

## 1.1 构建

- 对象的构造过程：
  - 1.内存中申请空间
  - 2.初始化附加成员
  - 3.调用构造函数
  - 4.返回对象地址
- 内存分配，CLR管理内存的区域：
  - 线程堆栈：值类型对象，由OS管理
  - GC堆：分配小对象（<85000B）,GC管理
  - LOH堆：分配大对象（>=85000B）,GC管理
- 创建实例的IL指令
  - newobj:创建引用类型对象
  - ldstr：创建字符串
  - newarr：创建数组
  - box：值类型进行装箱
- 堆栈
  - 分配在堆栈上的局部变量，从高到低分配
  - [演示代码 ShowStack_VariableAddress](./dotNetKnown.cs)
- 托管堆划分
  - GC Heap
  - Loader Heap：High-Frequency Heap/Low-Frequency Heap/Stub Heap
- 类型句柄 TypeHandle 4字节 对象的附加成员，指向对象的方法表
- 线程同步内存块 SyncBlockIndex,每个对象创建时的附加成员，指向同步的内存块
- NextObjPtr,指向下一个可分配内存地址
- 对象创建过程
  - 1.所需内存计算大小：CLR按照其继承层次进行搜索，计算类型以及所有父类型字段总字节数大小，直到Object，再加上附加项字节数+对齐要求补充字节数
  - 2.搜索可用空间：CLR在当前应用程序域内搜索可用的连续的空间大小，分配该内存，NextObjPtr指针指向下一个可分配内存地址（向高地址扩展）
  - 3.字段的存储顺序：从上到下，父类在子类钱前，若内存不足，则运行GC
  - 4.调用对象构造器，先父类 后子类顺序，连续分配的对象在内存中一定是连续的
- MethodTable方法表
  - MthodTable包含：所有方法、静态字段、接口信息等元数据信息
  - 一个类型在内存中对应一个MethodTable，TypeHandle在创建后，将指向该类型的MethodTable开始位置的偏移处
  - 通过对象调用方法：对象->TypeHandle->MethodTable->具体方法
  - Method Slot Table:方法槽表，排列顺序：继承的虚方法、引入的虚方法、实例方法、静态方法
- 静态字段的分配和释放
  - 保存在方法表的槽数组后，生命周期：应用程序域的创建到卸载

### 1.2 继承

- 继承、封装、多态
- 实现继承
  - 派生类与基类，基类单继承
- 接口继承
  - 派生类与接口，接口多继承
- 可见性问题
- 继承本质论
  - 对象创建过程：
    - 1.字段分配空间：顺序从父类到子类，存储顺序从上到下，最高层次类的字段在最前面，父类在前子类在后
    - 2.方法表创建：类第一次加载到应用程序域时创建，在对象创建时仅仅是将其附加成员TypeHandle指向该类的方法表在Loader Heap上的地址。顺序也是父类在前子类在后
  - 关注对象原则：调用方法取决于对象类型，而非引用类型
  - 执行就近原则：同名字段或方法，按照顺序查找使用，首先访问距离近的字段或方法
- 关于实现继承与接口继承问题（抽象类与接口问题）
  - 1.抽象类适用于族层概念，接口适用于不同类的通用功能问题
  - 2.接口侧重于Can-Do,抽象类适用于Is-A
  - 3.接口多定义对象的行为，抽象类用于对象的属性
  - 4.版本问题，最后使用抽象类，因为修改接口会强制要求修改所有派生类
  - 5.值类似只能使用接口，为密封类型
- 聚合与继承问题
- 基本原则：多聚合少继承、低耦合高内聚

### 1.3 封装

- 隐藏内部细节，对外提供统一的访问接口