# 05 运输层与应用层

## 运输层

- 运输层主要解决什么问题？主要提供什么服务？
- 重要概念：
  - 1.逻辑通信
  - 2.端口和套接字
  - 3.UDP
  - 4.TCP
  - 5.不可靠网络上的可靠传输
  - 6.停止等待协议
  - 7.ARQ协议
  - 8.TCP-滑动窗口、流量控制、拥塞控制、连接管理

### 5.1 运输层协议概述

- 运输层与网络层区别：
  - 网络层为主机之间提供逻辑通信
  - 运输层为应用进程之间提供端到端的逻辑通信
- 运输层的重要功能：
  - 1.复用 multipexing:发送方不同进程可共用同一运输层协议传输数据；
  - 2.分用 demultipexing:接收方运输层能够去掉报文首部后，将数据正确交付目的应用进程；
  - 3.差错检测：接收方对收到的报文进行差错检测
- 运输层目前只有两中运输协议：
  - UDP：无连接，用户数据报协议 User Datagram Protocol，基于IP协议，TPDU：UDP用户数据报
  - TCP：面向连接,传输控制协议 Transport Control Protocol，基于IP协议，TPDU：TCP报文段 segment
- 名词
  - TPDU Transport Protocol Data Unit 运输协议数据单元
- 应用成协议和运输层协议对照表

| 应用           | 应用层协议            | 运输层 |
| -------------- | --------------------- | ------ |
| 名字转换       | DNS 域名系统          | UDP    |
| 文件传送       | TFTP 简单文件传送协议 | UDP    |
| 路由选择协议   | RIP 路由信息协议      | UDP    |
| IP地址配置     | DHCP 动态主机配置协议 | UDP    |
| 网络管理       | SNMP 简单网络管理协议 | UDP    |
| 远程文件服务器 | NFS 网络文件系统      | UDP    |
| IP电话         | 专用协议              | UDP    |
| 流式多媒体通信 | 专用协议              | UDP    |
| 多播           | IGMP 网际组管理协议   | UDP    |
| 电子邮件       | SMTP 简单邮件传送协议 | TCP    |
| 远程终端接入   | TELNET 远程终端协议   | TCP    |
| 万维网         | HTTP 超文本传输协议   | TCP    |
| 文件传送       | FTP 文件传送协议      | TCP    |

- 运输层端口
  - 协议端口号 protocol port number(端口):仅用于本地计算机进程和运输层交互的层间接口
  - TCP/IP：使用16位端口号：0-65535
- 端口号分类：
  - 1.服务器使用的端口号
    - 1.1 熟知端口号或系统端口号：0-1023 (www.iana.org)
    - 1.2 登记端口号：1024-49151
  - 2.客户端使用的端口号：49152-65535

| FTP | TELNET | SMTP | DNS | TFTP | HTTP | SNMP | SNMP(trap) | HTTPS |
| --- | ------ | ---- | --- | ---- | ---- | ---- | ---------- | ----- |
| 21  | 23     | 25   | 53  | 69   | 80   | 161  | 162        | 443   |

### 5.2 UDP

- UDP特点：
  - 1.无连接：发送前不需要建立连接、发送结束不需要释放连接；
  - 2.使用尽最大努力交付，不保证可靠交付
  - 3.面向报文：一次发送一个报文，一次交付一个完整报文;发送方对上层交付的报文，添加首部后就交付给IP层，即不合并也不拆分，保留报文的边界；接收方收到IP层交付的报文，去除首部后交付给上层;
  - 4.没有拥塞控制
  - 5.支持一对一、一对多、多对一、多对多交互通信
  - 6.首部开销小：首部只有8字节
- UDP首部格式
  - UDP数据报=数据字段+首部字段

$$
\begin{aligned}
UDP数据报 & = IP首部 + IP数据报数据部分\\
& = IP首部 + UDP首部 + UDP数据部分\\
& = IP首部 + 源端口(2) + 目的端口(2) + 长度(2) + 检验和(2) + UDP数据部分\\
\end{aligned}
$$

$$
\begin{aligned}\\
UDP首部
& = 源端口(2)：源端口号，需要回信时选用，不需要时，用全0\\
& = 目的端口(2)：目的端口号，终点交付报文时必须\\
& = 长度(2)：UDP用户数据长度，最小值为8（仅首部）\\
& = 检验和(2)：检测UDP数据报在传输中是否有差错，若有差错则丢弃\\
\end{aligned}
$$

为计算首部中的校验和，需要在首部前添加12字节伪首部，组成临时用于计算校验和的数据报，仅有用计算校验和

- 计算过程
  - 1.生成：含伪首部的数据报不是偶数字节补0，按二进制反码计算16位和，结果取反放入检验和；
  - 2.检验：含伪首部的数据报，按二进制反码计算16位和，结果全1时，无差错时；

$$
\begin{aligned}\\
伪首部
& = 源IP地址(4)\\
& = 目的IP地址(4)\\
& = 长度(2)：UDP用户数据长度，最小值为8（仅首部）\\
& = 检验和(2)：检测UDP数据报在传输中是否有差错，若有差错则丢弃\\
\end{aligned}
$$

### 5.3 TCP

- TCP特点：
  - 1.面向连接的运输协议；
  - 2.每条TCP连接只能有两个端点（endpoint），即点对点通信；
  - 3.提供可靠交付服务：无差错、不丢失、不重复、按序到达；
  - 4.提供全双工通信；
  - 5.面向字节流：流-流入到进程或从进程流出的字节序列，不保证发送方的数据块和接收方数据块大小一致，但流保证一致；
- 名词定义：
  - 套接字（socket）或插口：TCP连接的端点，IP地址+端口号

### 5.4 可靠传输工作原理

- 理想传输条件（自然实现可靠传输）：
  - 1.传输信道不产生差错；
  - 2.接收方总能及时处理接收到的数据

#### 5.4.1 停止等待协议RDT

- 概述：发送方每发送完一个分组等待接收方确认，收到接收方确认后再发送下一个分组；
- 无差错情况：
  - A发送分组M给B，等待B回复确认；
  - B收到分组M，进行验证，验证通过，回复接收M确认；
- 出现差错：
  - A发送分组M给B，等待B回复确认；
  - B收到分组M，进行验证，验证失败，丢弃该分组，不发送回复确认；
  - A等待回复超时，重复发送分组M，并等待B确认；
  - 注意：
    - 1.发送者暂时保留已发送数据的副本，以用来重复发送；
    - 2.分组和确认分组都必须进行编号；
    - 3.超时时间设定；
- 确认丢失和确认迟到：
  - 情况：B发送的回复确认丢失，或者A超时重传；
  - B收到重传的分组后：
    - 1.丢弃重复分组，不上上层交付；
    - 2.向A发送确认；
- 自动重传请求ARQ：Automatic Repeat reQuest
- 信道利用率：
  - $T_D:A发送分组所需时间 = 分组长度/数据率$
  - $T_A:B发送确认分组需要时间$
  - $RTT:往返时间$

$$
信道利用率:U = \frac{T_D}{T_D + RTT + T_A}
$$

- 连续ARQ协议
  - 发送窗口
  - 发送方每收到一个确认，把滑动窗口向前移动一个分组位置
  - 接收方：采用累积确认，收到多个分组后，对按序到达的最后一个分组发送确认

### 5.5 TCP报文段首部

- 固定20字节+4n字节的选项

### 5.6 TCP可靠传输的实现

- 以字节为单位的滑动窗口

![alt](res\计算机网络-5-TCP-1.png)

![alt](res\计算机网络-5-TCP-2.png)

  - 发送方的滑动窗口：
    - 主要用途：在没收到接收方的确认情况下，发送方可以把窗口内的数据都发送出去，窗口内数据必须被暂存以备重新发送
    - 发送窗口大小限制：不能超过接收方的滑动窗口大小；可以根据网络拥塞状态减小窗口大小；不能超过发送缓存；
    - 窗口内数据：已发送数据（未收到确认）+未发送数据
    - 窗口变化：
      - 不动：未收到确认
      - 前移：收到确认
  - 接收方的滑动窗口：
    - 主要用途：暂存非按序到达的数据，限定发送数据量
    - 大小限制：不能大于接收缓存大小
- 注意：
  - 1.发送方窗口大小根据接收方窗口设置，但同一时刻，发送窗口和接收窗口大小并非总是大小一致：原因：网络传输延迟；网络拥塞发送方调整大小；
  - 2.对不按序到达数据的处理：通常暂存接收窗口，等待接收到缺少的字节后，按序交付上层；
  - 3.接收方必须具有累积确认功能：标准规定确认推迟不应超过0.5s；
- 超时重传时间的选择
  - 自适应算法：记录一个报文的发出时间，以及相应的确认时间，时间差为RTT，TCP保留RTT的一个加权平均往返时间RTTs（即平滑的往返时间）：计算公式

$$
New\ RTTs = (1 - \alpha) \times (old\ RTTs) + \alpha \times (new\ RTT\ sample)\\
 0 \leq \alpha <1,RFC 建议:\alpha = 1/8
$$

超时计时器设置的超时重传时间：RTO(RetransmissionTime-Out):
$RTO = RTTs + 4*RTT_D,RTT_D为RTT的偏差的加权平均值$</br>
Karn算法

- GBN协议
  - 接收方累积确认
- 选择确认协议SR SACK-SR
  - 解决问题：收到报文无差错，但未按序到达，缺少中间数据时，要求只重传缺少数据而不重传已正确收到数据
  - 使用选择确认，需要在TCP建立连接时在首部选项添加“允许SACK”选项，首部长度最多40B，指明一个边界用4B（32位序号），指明一个字节块需要2个边界，还需要另外两个字节：一个指明SACK选项，一个指明选择长度

### 5.7 TCP流量控制

- 利用滑动窗口实现流量控制
  - 接收方发送报文丢失导致的等待死锁问题：持续计数器 - 零窗口探测报文
- TCP传输效率
  - TCP报文发生时机：
    - 1.TCP维持一个等于MSS（最大报文长度）的变量，只有缓存数据达到该值，即可发送；
    - 2.发送方应用指定发送数据段，即推送操作；
    - 3.发送方的计时器时间到了，开始发送数据；
  - Nagle算法：
    - 若发送应用把要发送数据逐个字节送到TCP的发送缓存，则发送方把第一个字节的数据发送出去，然后把后面的数据进行缓存。当发送方接收到第一个数据的字符确认后，再把发送缓存中的所有数据组装成报文发送，同时继续对随后到达的数据进行缓存。只有在接收到前一个报文确认后才继续发送下一个报文。
    - Nagle规定：当到达的数据已达到发送窗口大小的一半或已达到报文段最大长度时，立即发送一个报文；
  - 糊涂窗口综合征（silly windows syndrome）
    - 1.前提：TCP接收窗口已满，上层应用一次只从接收缓存读取1字节，接收方向发送方发送确认，窗口值设置为1；发送方发送1字节，接收方回放确认，仍将窗口值设置为1;
    - 解决：接收方等待一段时间；接收方等待接收缓存已有一般空闲；

### 5.8 TCP拥塞控制

- 拥塞控制的一般原理
  - 网络资源、拥塞 congestion
  - 拥塞控制：防止过多的数据注入到网络中。使网络中的路由器或链路不致过载
  - 拥塞控制前提：网络能够承受现有的网络负荷；
  - 拥塞控制：全局性控制，涉及到所有主机、所有路由器、以及与降低网络传输性能的因素；
  - 流量控制：点对点通信量的控制，抑制发送端发送的数据；
- TCP拥塞控制方法
  - 假定：
    - 1.数据单向传送，对方只传送确认报文；
    - 2.接收方总有足够大的缓存空间，发送窗口大小由网络的拥塞程度决定；
  - 慢开始和拥塞避免
    - 发送方：维持一个拥塞窗口cwnd的状态变量，拥塞窗口大小取决于网络拥塞程度，发送方让发送窗口等于拥塞窗口；
    - 发送原则：网络没有出现拥塞，就可以增大拥塞窗口，网络出现拥塞，减小拥塞窗口
    - 判断网络出现拥塞机制：确认超时
    - 慢开始算法：
      - 主机开始发送数据时，由小到大逐渐增大发送窗口，一般规定初始cwnd值为不超过2-4个SMSS（最大报文段）
      - 每收到一个对新的报文段确认后，可以把cwnd增大最多一个SMSS，cwnd每次增大量 = min（N,SMSS）,N为刚收到确认的字节数
      - 每经过一个传输轮次，拥塞窗口cwnd加倍，传输轮次的时间：RTT
      - 防止cwnd增长过大：设置慢开始门极限ssthresh状态变量值：当cwnd < ssthresh时，采用慢开始算法；当cwnd>ssthresh时，采用拥塞避免算法；当cwnd=ssthresh时，两者均可
    - 拥塞避免：
      - 让cwnd缓慢增大，每经过一个RTT，cwnd加1
  - 快重传
    - 让发送方尽快知道个别报文段丢失
    - 立即发送确认，发送方连续收到3个M2重复确认，说明M3丢失，应当立即重传M3
  - 加法增大与乘法减小（AIMD Additive Increase Multiplicative Decrease）

![alt](res\计算机网络-5-运输层-TCP拥塞控制流程图.png)

 - 考虑接收方缓存空间有限问题：
   - 发送方窗口大小一定不能超过对方给出的接收方窗口值rwnd
   - 发送方窗口上限 = Min[rwnd,cwnd]

#### 5.8.3 主动队列管理 AQM

- 考虑网络层取的拥塞控制策略：
  - 路由器处理分组的策略：FIFO - 先进先出，尾部丢弃策略（tail-drop policy）
  - 全局同步(global synchronization):多个TCP在同一时间突然进入慢开始状态
  - 主动队列管理（Active Queue Management）：队列长度达到预警值后，主动丢弃到达的分组
  - AQM实现：RED - 随机早起检测 Random Early Detection
    - RED 实现：
      - 1.平均队列长度小于最小门限，将分组放入待处理队列；
      - 2.平均队列长度大于最小门限但小于最大门限，将已概率P丢弃分组；
      - 3.评价队列长度大于最大门限，丢弃分组；

### 5.9 TCP的运输连接管理

- 运输连接的三个阶段：连接建立、数据传送、连接释放
- TCP连接建立要解决的问题：
  - 1.使双方确知对方的存在；
  - 2.允许双方协商参数；
  - 3.能够对运输实体资源进行分配；
- 规定：客户端client:连接的发起者；服务端server：连接的等待者；

#### 5.9.1 TCP连接建立

- 需要交换三个TCP报文握手：
- 开始状态：C-Closed,S-Closed;
- 准备：S-Listen(开启监听)；
- C-SYN-SNT(发送连接请求)，SYN=1，seq=x，连接建立请求报文：SYN=1,ack=x;
- S收到连接后，同意连接，SYN=1，ACK=1,ack=x+1,seq=y,进入SYN-RCVD,确认报文ACK=1,ack=x+1,同步报文：SYN=1，seq=y;
- C收到连接确认后，回复确认，ACK=1,ack=y+1,C进入ESTABLISHED,回复确认报文：ACK=1,seq=x+1,ack=y+1;
- S收到确认后，进入ESTABLISHED；

![alt](res\计算机网络-5-运输层-TCP连接建立图.png)

- 为什么Client最后需要发送一次确认？
  - 1.防止已失效连接请求回传到服务端

#### 5.9.2 TCP连接释放

- 需要四个TCP握手报文
- 开始状态：C-ESTABLISHED,S-ESTABLISHED;
- 客户端收到上层通知，发出连接释放请求：FIN=1，seq=u,状态进入FIN-WAIT1；
- 服务端收到客户端发送的连接释放请求，进行确认回复：ACK=1，seq=v,ack=u+1,服务端通知上层客户端请求连接释放，服务端状态进入CLOSE-WAIT；
- 客户端收到释放请求确认，状态进入FIN-WAIT-2；
- 服务端收到上层关闭通知，服务端发出关闭请求：FIN=1，ACK=1，seq=w,ack=u+1,服务端进入状态：LAST-WAIT；
- 客户端收到服务端连接释放请求，发送确认回复：ACK=1，seq=u+1,ack=w+1,状态进入TIME-WAIT，开启2MSL的时间等待计时器
- 服务端收到确认回复后，关闭连接，状态进入CLOSED；
- 客户端等待计时器超时后，状态进入CLOSED；

![alt](res\计算机网络-5-运输层-TCP连接释放图.png)

- MSL：最长报文寿命Maxmum Segment Lifetime
- 为什么客户端在TIME-WAIT状态必须等待2MSL的时间？
  - 1.保证客户端发送的最后一个ACK报文能够达到B，若未到达B，B超时后，会重新发送FIN+ACK报文；
  - 2.防止已失效的连接请求报文段出现；
- TCP的保活计时器keepalive timer：用于服务端定时监测客户端是否存活的问题，防止服务端在客户端出现故障后的等待问题；

#### 5.9.3 TCP有限状态机

![alt](res\计算机网络-5-运输层-TCP有限状态机.png)

### 总结

- 重要概念：
  - 运输层主要功能：进程间的逻辑通信
  - 运输层主要的协议：TCP UDP
  - 端口号与套接字
  - UDP特点
  - UDP报文格式
  - TCP特点
  - TCP报文格式
  - 停止等待协议
  - 超时重传
  - 连续ARQ协议
  - TCP滑动窗口机制
  - 流量控制、TCP如何通过滑动窗口进行流量控制
  - 拥塞控制、TCP如何通过滑动窗口进行拥塞控制、拥塞窗口cwnd、TCP拥塞控制的四种算法：慢开始、拥塞避免、快重传、块恢复
  - TCP连接建立过程
  - TCP连接释放过程

## 6 应用层


